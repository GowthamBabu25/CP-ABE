# -*- coding: utf-8 -*-
"""ABC3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KtdHGrFoP9BfVjyxQu0PUxojmwcLGZ8i
"""

import pandas as pd
import random

df = pd.read_csv("https://raw.githubusercontent.com/GowthamBabu25/dataset/main/student_data.csv")
cols = df.columns
print(cols)

# Read the dataset into a pandas DataFrame
df = pd.read_csv("https://raw.githubusercontent.com/GowthamBabu25/dataset/main/student_data.csv")

num_records = 100
num_columns = 15

# Initialize a counter variable
count = 0

# Initialize an empty list to store the dictionaries
policy = []

# Iterate over each record in the DataFrame
for index, row in df.iterrows():
    # Check if the desired number of records has been reached
    if count >= num_records:
        break

    # Select a random subset of columns
    selected_columns = random.sample(df.columns.tolist(), num_columns)

    # Create an empty dictionary to store the column-value pairs
    output_dict = {}

    # Iterate over the selected columns
    for column in selected_columns:
        # Extract the value for the current column
        value = row[column]

        # Add the column-value pair to the dictionary
        output_dict[column] = value

    # Append the dictionary to the output list
    policy.append(output_dict)

    # Increment the counter variable
    count += 1

# Print the output list

output_list = []

for i, policy in enumerate(policy):
    resource = f"resource{i+1}"
    output_dict = {"resource": resource, "condition": policy}
    output_list.append(output_dict)

print(output_list)
def fitness_function(attribute_set, access_policies):
    coverage_score = 0
    for policy in access_policies:
        if all(attr in attribute_set for attr in policy["condition"]):
            coverage_score += 1
    redundancy_score = -len(set(attribute_set))
    exclusivity_score = 0
    for policy1 in access_policies:
        for policy2 in access_policies:
            if policy1["resource"] != policy2["resource"]:
                if set(policy1["condition"]).issubset(set(policy2["condition"])):
                    exclusivity_score -= 1
    fitness_score = 0.7 * coverage_score + 0.2 * redundancy_score + 0.1 * exclusivity_score
    return fitness_score

def generate_initial_population(num_bees, num_attributes, possible_attributes):
    population = []
    for i in range(num_bees):
        solution = random.sample(possible_attributes, num_attributes)
        population.append(solution)
    return population

def modify_solution(solution, possible_attributes):
    random_index = random.randrange(len(solution))
    solution[random_index] = random.choice(possible_attributes)
    return solution

def employed_bee_phase(population, fitness_values, access_policies, possible_attributes):
    new_population = []
    for i in range(len(population)):
        current_solution = population[i]
        new_solution = modify_solution(current_solution, possible_attributes)
        new_fitness = fitness_function(new_solution, access_policies)
        if new_fitness > fitness_values[i]:
            new_population.append(new_solution)
            fitness_values[i] = new_fitness
        else:
            new_population.append(current_solution)
    return new_population, fitness_values

def onlooker_bee_phase(population, fitness_values, access_policies, possible_attributes):
    probabilities = [fitness / sum(fitness_values) for fitness in fitness_values]
    selected_solutions = random.choices(population, weights=probabilities, k=len(population))
    new_population, fitness_values = employed_bee_phase(selected_solutions, fitness_values, access_policies, possible_attributes)
    return new_population, fitness_values

def scout_bee_phase(population, fitness_values, max_trials, num_attributes, possible_attributes, access_policies):
    trials = [0]*len(population)
    for i in range(len(population)):
        if trials[i] >= max_trials:
            population[i] = random.sample(possible_attributes, num_attributes)
            fitness_values[i] = fitness_function(population[i], access_policies)
            trials[i] = 0
        else:
            trials[i] += 1
    return population, fitness_values

def abc_algorithm(num_bees, num_attributes, max_iterations, max_trials, possible_attributes, access_policies):
    population = generate_initial_population(num_bees, num_attributes, possible_attributes)
    print(population)
    fitness_values = [fitness_function(solution, access_policies) for solution in population]

    for iteration in range(max_iterations):
        population, fitness_values = employed_bee_phase(population, fitness_values, access_policies, possible_attributes)
        fitness_values = [fitness_function(solution, access_policies) for solution in population]
        population, fitness_values = onlooker_bee_phase(population, fitness_values, access_policies, possible_attributes)
        fitness_values = [fitness_function(solution, access_policies) for solution in population]
        population, fitness_values = scout_bee_phase(population, fitness_values, max_trials, num_attributes, possible_attributes, access_policies)

    best_solution = population[fitness_values.index(max(fitness_values))]
    return best_solution

possible_attributes = ["student_id", "school", "sex", "age", "address_type", "family_size", "parent_status", "mother_education", "father_education", "mother_job", "father_job", "school_choice_reason", "stdnt_major", "guardian", "travel_time", "study_time", "class_failures", "school_support", "family_support", "extra_paid_classes", "activities", "nursery_school", "higher_ed", "internet_access", "romantic_relationship", "family_relationship", "free_time", "social", "weekday_alcohol", "weekend_alcohol", "health", "absences", "grade_1", "grade_2", "final_grade"]
access_policies = output_list
best_attribute_set = abc_algorithm(num_bees=100, num_attributes=5, max_iterations=50, max_trials=10, possible_attributes=possible_attributes, access_policies=access_policies)
print("Selected attribute set:", best_attribute_set)